"# Development Next Steps Plan (January 31, 2026)

## Context

After stepping away from development for several months, this document outlines a strategic path to continue the work that was in progress. The last commit (`84f00db`) added event check-in status API and UI while still relying on Unlock Locksmith, along with updated NFT collection links. The `docs/high-priority-outstanding-tasks.md` file documented the planned architecture shifts to reduce reliance on Unlock backends.

## Current State

- Event check-in functionality exists but still depends on Locksmith API
- Membership metadata still relies on Unlock/Locksmith
- The `roster-cache.ts` implementation demonstrates a successful pattern for storing on-chain data locally

## Strategic Roadmap

### Phase 1: Event Check-in Migration (Highest Priority)

#### 1. Create Event Check-in Database Table
- **Objective**: Establish local source of truth for attendance/check-in status
- **Implementation Details**:
  - Create DynamoDB table using similar pattern to `lib/admin/roster-cache.ts`
  - Schema should include:
    ```typescript
    {
      pk: `EVENT_CHECKIN#${lockAddress}`,
      sk: tokenId,
      checkedInAt: string | null,  // ISO timestamp
      checkedInBy: string | null,   // Admin wallet address
      method: 'qr' | 'manual',      // How check-in was recorded
      notes: string | null,
      ownerAddress: string          // For quick lookups
    }
    ```
- **Verification Criteria**:
  - Table deployed in all environments (dev, staging, prod)
  - IAM permissions properly configured
  - Backup/restore procedures documented

#### 2. Implement Database-Backed Check-in Status
- **Objective**: Modify API to use local database as primary source
- **Implementation Details**:
  - Update `app/api/events/checkin-status/route.ts` to:
    * First check local database for status
    * If not found, fall back to Locksmith (transition period)
    * Save responses from Locksmith to database for future requests
  - Add configuration flag to enable/disable database storage
- **Verification Criteria**:
  - New check-ins are stored in DB without Locksmith dependency
  - Existing check-in data is preserved during transition
  - Fallback to Locksmith works when DB is empty/unavailable

#### 3. Update Admin Check-in UI
- **Objective**: Modify admin interface to use new endpoint and show sync status
- **Implementation Details**:
  - Update `app/admin/admin-client.tsx` check-in components
  - Add visual indicators:
    * Local DB status (green)
    * Locksmith sync status (yellow during transition)
    * Error indicators if synchronization fails
  - Add manual sync button for admin users
- **Verification Criteria**:
  - Admins can see both local and Locksmith status during transition
  - Manual sync functionality works as expected
  - UI properly handles edge cases (e.g., conflicting data)

#### 4. Implement QR Code Generation
- **Objective**: Eliminate dependency on Locksmith for QR codes
- **Implementation Options**:
  - **Option A**: Signed payload generated by application
    * QR contains signed token with lock address, token ID, and expiration
    * Server validates signature before processing check-in
  - **Option B**: Short-lived tokens stored in database
    * Generate UUID token with TTL (e.g., 15 minutes)
    * QR code contains URL with token
- **Decision Factors**:
  - Security requirements
  - Implementation complexity
  - Need for QR reuse (Option A allows multiple scans)
- **Verification Criteria**:
  - New QR codes work for check-in
  - Old Locksmith QR codes continue to work during transition period
  - Security audit completed for chosen approach

#### 5. Create Data Migration Plan
- **Objective**: Bring historical check-in data into local database
- **Implementation Details**:
  - Write script to backfill existing check-in data from Locksmith
  - Implement verification step comparing counts between systems
  - Add reconciliation UI for admin to resolve discrepancies
- **Verification Criteria**:
  - Historical data migration completes successfully
  - Validation shows no significant discrepancies (>99.5% match)
  - Reconciliation process documented for edge cases

### Phase 2: Membership Metadata Migration

#### 6. Design Membership Metadata Schema
- **Objective**: Store and serve membership tier metadata from own DB
- **Implementation Details**:
  - Create DynamoDB table with schema similar to event metadata approach
  - Key structure: `pk = MEMBERSHIP_METADATA#${tierAddress}, sk = META`
  - Include fields for name, description, image URL, tier ordering
- **Verification Criteria**:
  - Table deployed with proper indexes
  - Data model supports expected use cases (filtering, sorting)
  - Backup plan established

#### 7. Build Admin UI for Metadata Management
- **Objective**: Enable editing of membership metadata through admin interface
- **Implementation Details**:
  - Extend existing admin UI with new section for membership metadata
  - Include image upload capability (via S3 or similar)
  - Add versioning/audit trails for metadata changes
- **Verification Criteria**:
  - Admins can create and edit membership tier information
  - Changes are reflected in frontend views immediately
  - Audit history available for all changes

#### 8. Update Membership Views
- **Objective**: Modify frontend components to use database metadata
- **Implementation Details**:
  - Update `components/home/NftCollection.tsx` and related components
  - Implement fallback to on-chain name if DB data missing or stale
  - Add cache invalidation strategy
- **Verification Criteria**:
  - Frontend displays metadata from database correctly
  - Fallback to on-chain data works when DB unavailable
  - Performance metrics show improvement

#### 9. Evaluate tokenURI Update Strategy
- **Objective**: Determine path for fully decoupling from on-chain metadata
- **Implementation Options**:
  - **Option A**: Leave tokenURI pointing to Unlock, but mirror data
    * Lowest risk but still dependent on Unlock infrastructure
  - **Option B**: Update tokenURI via governance process after testing
    * More work but complete independence
- **Verification Criteria**:
  - Decision documented with rationale
  - Migration path clear for existing tiers and new tiers
  - Rollback plan established if issues arise

### Phase 3: Documentation & Transition Planning

#### 10. Update Deployment Runbook
- **Objective**: Revise documentation for new processes
- **Implementation Details**:
  - Update `docs/high-priority-outstanding-tasks.md` with new workflow
  - Add section to "Deploy a New Event Lock" procedure for metadata registration
  - Create checklist for new team members on the updated workflow
- **Verification Criteria**:
  - Updated documentation covers all critical paths
  - New team members can successfully deploy using the guide
  - Outdated references to Locksmith removed

#### 11. Create Monitoring & Alerting
- **Objective**: Ensure reliability of new systems
- **Implementation Details**:
  - Add metrics for check-in sync status (CloudWatch/Datadog)
  - Set up alerts for:
    * DB write failures
    * Significant data discrepancies between systems
    * High latency in check-in operations
  - Create dashboard showing sync health
- **Verification Criteria**:
  - Monitoring covers all critical failure points
  - Alerts trigger appropriately during simulated failures
  - Dashboard provides clear operational visibility

#### 12. Plan Full Cutover
- **Objective**: Safely transition from Locksmith dependency to full independence
- **Implementation Details**:
  - Define success metrics for transition (e.g., <0.5% discrepancy)
  - Create phased rollout plan:
    * Week 1: New events use new system only
    * Week 2: All new check-ins, historical data read-only
    * Week 3: Full cutover with Locksmith as fallback only
  - Document rollback procedure for each phase
- **Verification Criteria**:
  - Cutover plan approved by relevant stakeholders
  - Rollback procedures tested in staging environment
  - Monitoring confirms stability at each phase

## Key Considerations Before Implementation

- **Environment Strategy**: Which environment to prioritize first (dev, staging, production)?
- **Transition Duration**: How long should the parallel operation period last?
- **Feature Flags**: Should implementation use feature flags for gradual rollout?
- **Historical Data Scope**: How much historical data needs migration versus acceptable to leave in Locksmith?
- **Team Readiness**: Is the team prepared for potential issues during transition?

## Next Immediate Actions

1. Review and approve this roadmap with stakeholders
2. Prioritize which phase 1 items to tackle first based on risk assessment
3. Set up feature flag system if not already in place
4. Create tickets with detailed acceptance criteria for first few items

This document should be reviewed and updated regularly during implementation to reflect lessons learned and any changes to the strategic direction."